<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Political Canvasser with Phaser 3 - Results & Winner</title>
  <style>
    body { margin: 0; }
    canvas { display: block; margin: 0 auto; }
  </style>
  <!-- Import Phaser 3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
<script>
  let playerParty = null;

  // Menu Scene: Party selection
  class MenuScene extends Phaser.Scene {
    constructor() {
      super({ key: "MenuScene" });
    }
    create() {
      const centerX = this.cameras.main.width / 2;
      const centerY = this.cameras.main.height / 2;
      this.add.text(centerX, centerY - 100, "Choose Your Party", { font: "32px Arial", fill: "#fff" }).setOrigin(0.5);
      const parties = ["blue", "red", "yellow", "green"];
      parties.forEach((party, index) => {
        let btn = this.add.text(centerX, centerY - 20 + index * 50, party.toUpperCase(), { font: "28px Arial", fill: party });
        btn.setOrigin(0.5);
        btn.setInteractive();
        btn.on("pointerdown", () => {
          playerParty = party;
          this.scene.start("GameScene");
        });
      });
    }
  }

  // Game Scene: Main gameplay and results display.
  class GameScene extends Phaser.Scene {
    constructor() {
      super({ key: "GameScene" });
    }
    preload() {
      // Create player texture (white square 30x30).
      this.add.graphics()
        .fillStyle(0xffffff)
        .fillRect(0, 0, 30, 30)
        .generateTexture("player", 30, 30)
        .destroy();

      // Create house texture with door and letterbox.
      let houseGfx = this.add.graphics();
      houseGfx.fillStyle(0x888888);
      houseGfx.fillRect(0, 20, 80, 80);
      houseGfx.fillStyle(0x444444);
      houseGfx.fillTriangle(0, 20, 40, -10, 80, 20);
      houseGfx.fillStyle(0x654321);
      houseGfx.fillRect(30, 60, 20, 40);
      houseGfx.fillStyle(0xffffff);
      houseGfx.fillRect(38, 75, 10, 10);
      houseGfx.generateTexture("house", 80, 100);
      houseGfx.destroy();

      // Create leaflet texture (small green circle, radius 5).
      let leafletGfx = this.add.graphics();
      leafletGfx.fillStyle(0x00ff00);
      leafletGfx.fillCircle(5, 5, 5);
      leafletGfx.generateTexture("leaflet", 10, 10);
      leafletGfx.destroy();

      // Preload the "bleep" sound.
      this.load.audio("bleep", "https://labs.phaser.io/assets/audio/SoundEffects/key.wav");
    }
    create() {
      // Use default black background.
      this.houseSpacing = 300;
      this.totalHouses = 10;
      this.houses = [];
      // Global votes only update on a successful leaflet delivery.
      this.totalVotes = { blue: 0, red: 0, yellow: 0, green: 0 };
      this.playerLives = 3;
      this.gameOver = false;
      this.playerLost = false;  // Flag to indicate if player lost (0 lives).
      this.leaflet = null;
      this.houseSpeed = 2;

      // Create player sprite at default spawn (400,500).
      this.player = this.physics.add.sprite(400, 500, "player");
      this.player.setCollideWorldBounds(true);

      // Create houses (positioned using top-left coordinates).
      this.houseGroup = this.physics.add.group();
      for (let i = 0; i < this.totalHouses; i++) {
        let x = 800 + i * this.houseSpacing;
        let y = Phaser.Math.Between(250, 450);
        let house = this.physics.add.sprite(x, y, "house");
        house.setOrigin(0, 0);
        house.setImmovable(true);
        house.votes = Phaser.Math.Between(1, 4);
        house.hitLetterbox = false;
        house.evaluated = false;
        house.collided = false;
        // Define full house rectangle.
        house.fullRect = new Phaser.Geom.Rectangle(x, y, 80, 100);
        // Define door region (safe passage): door at (30,60) relative to house.
        house.doorRect = new Phaser.Geom.Rectangle(x + 30, y + 60, 20, 40);
        // Define letterbox region (target): at (38,75) relative to house.
        house.letterbox = new Phaser.Geom.Rectangle(x + 38, y + 75, 10, 10);
        this.houses.push(house);
        this.houseGroup.add(house);
      }

      // Set up keyboard input (vertical, horizontal movement).
      this.cursors = this.input.keyboard.createCursorKeys();
      this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

      // Player-house collision.
      this.physics.add.overlap(this.player, this.houseGroup, this.handlePlayerHouseCollision, null, this);

      // Set up HUD.
      this.voteText = this.add.text(10, 10, "", { font: "16px Arial", fill: "#fff" });
      this.livesText = this.add.text(10, 30, "", { font: "16px Arial", fill: "#fff" });
      this.updateHUD();

      // Set up Game Over text (hidden until round ends).
      this.gameOverText = this.add.text(400, 300, "Game Over\nClick to Play Again", { font: "32px Arial", fill: "#fff", align: "center" });
      this.gameOverText.setOrigin(0.5);
      this.gameOverText.setVisible(false);
      this.input.on("pointerdown", () => {
        if (this.gameOver) {
          this.scene.restart();
        }
      });
    }
    updateHUD() {
      this.voteText.setText("Votes - Blue: " + this.totalVotes.blue + "  Red: " + this.totalVotes.red + "  Yellow: " + this.totalVotes.yellow + "  Green: " + this.totalVotes.green);
      this.livesText.setText("Lives: " + this.playerLives);
    }
    // When the player collides with a house, lose a life and respawn.
    handlePlayerHouseCollision(player, house) {
      if (!house.collided) {
        house.collided = true;
        this.playerLives--;
        this.updateHUD();
        if (this.playerLives > 0) {
          // Respawn at default spawn.
          this.player.setPosition(400, 500);
        } else {
          this.playerLost = true;
          this.endGame();
        }
      }
    }
    computeVotes(voteCount, boosted) {
      let distribution = { blue: 0, red: 0, yellow: 0, green: 0 };
      for (let i = 0; i < voteCount; i++) {
        let rnd = Math.random();
        if (boosted) {
          if (rnd < 0.5) {
            distribution[playerParty]++;
          } else {
            let others = ["blue", "red", "yellow", "green"].filter(p => p !== playerParty);
            let idx = Math.floor(Math.random() * others.length);
            distribution[others[idx]]++;
          }
        } else {
          if (rnd < 0.25) {
            distribution["blue"]++;
          } else if (rnd < 0.5) {
            distribution["red"]++;
          } else if (rnd < 0.75) {
            distribution["yellow"]++;
          } else {
            distribution["green"]++;
          }
        }
      }
      return distribution;
    }
    // Creates a brief explosion effect for a mis-delivered leaflet.
    explodeLeaflet(leaflet) {
      let explosion = this.add.circle(leaflet.x, leaflet.y, 10, 0xff0000);
      this.tweens.add({
        targets: explosion,
        alpha: 0,
        duration: 300,
        onComplete: () => { explosion.destroy(); }
      });
    }
    // At the end of the round, display a bar chart of scores.
    showResults() {
      let scores = [
        { party: "blue", score: this.totalVotes.blue },
        { party: "red", score: this.totalVotes.red },
        { party: "yellow", score: this.totalVotes.yellow },
        { party: "green", score: this.totalVotes.green }
      ];
      // Sort descending so highest score is first.
      scores.sort(function(a, b) { return b.score - a.score; });
      let maxScore = scores[0].score || 1;
      const partyColors = { blue: 0x0000ff, red: 0xff0000, yellow: 0xffff00, green: 0x00ff00 };
      let chartX = 50;
      let chartY = 550;
      let barWidth = 100;
      let maxBarHeight = 200;
      let gap = 20;
      let graphics = this.add.graphics();
      scores.forEach(function(entry, index) {
        let barHeight = (entry.score / maxScore) * maxBarHeight;
        let x = chartX + index * (barWidth + gap);
        let y = chartY - barHeight;
        graphics.fillStyle(partyColors[entry.party], 1);
        graphics.fillRect(x, y, barWidth, barHeight);
        this.add.text(x + barWidth / 2, chartY + 5, entry.party.toUpperCase() + "\n" + entry.score,
          { font: "20px Arial", fill: "#fff", align: "center" }).setOrigin(0.5);
      }, this);
      // If the winning party matches the player's chosen party and the player did not lose, display "WINNER".
      if (!this.playerLost && scores[0].party === playerParty) {
        this.add.text(400, 100, "WINNER", { font: "80px Arial", fill: "#fff" }).setOrigin(0.5);
      }
    }
    update(time, delta) {
      if (this.gameOver) return;
      // Allow horizontal and vertical movement.
      if (this.cursors.left.isDown) {
        this.player.setVelocityX(-150);
      } else if (this.cursors.right.isDown) {
        this.player.setVelocityX(150);
      } else {
        this.player.setVelocityX(0);
      }
      if (this.cursors.up.isDown) {
        this.player.setVelocityY(-150);
      } else if (this.cursors.down.isDown) {
        this.player.setVelocityY(150);
      } else {
        this.player.setVelocityY(0);
      }
      // Launch a leaflet on space press (only one at a time).
      if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && !this.leaflet) {
        this.leaflet = this.physics.add.sprite(this.player.x, this.player.y - 15, "leaflet");
        this.leaflet.setVelocityY(-300);
      }
      if (this.leaflet) {
        if (this.leaflet.y < 0) {
          this.leaflet.destroy();
          this.leaflet = null;
        } else {
          let leafletCenter = { x: this.leaflet.x, y: this.leaflet.y };
          for (let i = 0; i < this.houses.length; i++) {
            let house = this.houses[i];
            house.fullRect = new Phaser.Geom.Rectangle(house.x, house.y, 80, 100);
            house.doorRect = new Phaser.Geom.Rectangle(house.x + 30, house.y + 60, 20, 40);
            house.letterbox = new Phaser.Geom.Rectangle(house.x + 38, house.y + 75, 10, 10);
            if (Phaser.Geom.Rectangle.ContainsPoint(house.fullRect, leafletCenter)) {
              if (Phaser.Geom.Rectangle.ContainsPoint(house.letterbox, leafletCenter)) {
                if (!house.hitLetterbox) {
                  house.hitLetterbox = true;
                  let distribution = this.computeVotes(house.votes, true);
                  for (let p in distribution) {
                    this.totalVotes[p] += distribution[p];
                  }
                  this.updateHUD();
                  // Tint the house based on the winning vote.
                  let maxVotes = Math.max(distribution.blue, distribution.red, distribution.yellow, distribution.green);
                  let winners = [];
                  if (distribution.blue === maxVotes) winners.push("blue");
                  if (distribution.red === maxVotes) winners.push("red");
                  if (distribution.yellow === maxVotes) winners.push("yellow");
                  if (distribution.green === maxVotes) winners.push("green");
                  if (winners.length === 1) {
                    let tint;
                    switch(winners[0]) {
                      case "blue": tint = 0x0000ff; break;
                      case "red": tint = 0xff0000; break;
                      case "yellow": tint = 0xffff00; break;
                      case "green": tint = 0x00ff00; break;
                    }
                    house.setTint(tint);
                  } else {
                    house.clearTint();
                  }
                  this.sound.play("bleep");
                }
                this.leaflet.destroy();
                this.leaflet = null;
                break;
              }
              if (!Phaser.Geom.Rectangle.ContainsPoint(house.doorRect, leafletCenter)) {
                this.explodeLeaflet(this.leaflet);
                this.leaflet.destroy();
                this.leaflet = null;
                break;
              }
            }
          }
        }
      }
      this.houses.forEach(function(house) {
        if (!house.evaluated) {
          house.x -= this.houseSpeed;
          house.fullRect = new Phaser.Geom.Rectangle(house.x, house.y, 80, 100);
          house.doorRect.setTo(house.x + 30, house.y + 60, 20, 40);
          house.letterbox.setTo(house.x + 38, house.y + 75, 10, 10);
          if (house.x + 80 < 0) {
            house.evaluated = true;
            house.destroy();
          }
        }
      }, this);
      if (this.houses.every(function(h) { return h.evaluated; })) {
        this.endGame();
      }
    }
    endGame() {
      this.gameOver = true;
      this.player.setVelocity(0);
      if (this.leaflet) {
        this.leaflet.destroy();
        this.leaflet = null;
      }
      this.gameOverText.setVisible(false);
      this.showResults();
    }
  }

  const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    backgroundColor: "#000000",
    physics: { default: "arcade", arcade: { debug: false } },
    scene: [MenuScene, GameScene]
  };

  const game = new Phaser.Game(config);
</script>
</body>
</html>
