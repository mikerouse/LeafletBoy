<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Political Canvasser with Phaser 3 - Mobile Controls</title>
  <style>
    body { margin: 0; }
    canvas { display: block; margin: 0 auto; background-color: #333333; }
  </style>
  <!-- Import Phaser 3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
<script>
  // Global party color mapping.
  const partyColors = {
    blue: 0x0000ff,
    red: 0xff0000,
    yellow: 0xffff00,
    green: 0x00ff00,
    turquoise: 0x40E0D0
  };

  let playerParty = null;

  // Menu Scene.
  class MenuScene extends Phaser.Scene {
    constructor() {
      super({ key: "MenuScene" });
    }
    create() {
      const centerX = this.cameras.main.width / 2;
      const centerY = this.cameras.main.height / 2;
      this.add.text(centerX, centerY - 140, "Choose Your Party", { font: "32px Arial", fill: "#fff" }).setOrigin(0.5);
      
      // Rules text.
      const rulesText = "Move with arrows or WASD and press spacebar to deliver a leaflet.\n" +
                        "The number of voters in each household is displayed above the door.\n" +
                        "You have to hit the letterbox to win any votes â€“ and there is no guarantee that everyone\n" +
                        "in the household will vote for your party even after you deliver a leaflet to them.\n" +
                        "Don't trespass onto any houses or you will lose a life.";
      this.add.text(centerX, centerY - 80, rulesText, { font: "18px Arial", fill: "#fff", align: "center" }).setOrigin(0.5);

      // Party selection as colored blocks.
      const parties = ["blue", "red", "yellow", "green", "turquoise"];
      parties.forEach((party, index) => {
        let block = this.add.rectangle(centerX, centerY + 20 + index * 60, 100, 40, partyColors[party]);
        block.setStrokeStyle(2, 0xffffff);
        block.setInteractive();
        block.on("pointerdown", () => {
          playerParty = party;
          this.scene.start("GameScene");
        });
      });
    }
  }

  // Game Scene.
  class GameScene extends Phaser.Scene {
    constructor() {
      super({ key: "GameScene" });
    }
    preload() {
      // Create a person-like player texture.
      let playerGfx = this.add.graphics();
      // Head.
      playerGfx.fillStyle(0xffcc99, 1);
      playerGfx.fillCircle(15, 10, 10);
      // Body (using player's party color if set, else white).
      let bodyColor = playerParty ? partyColors[playerParty] : 0xffffff;
      playerGfx.fillStyle(bodyColor, 1);
      playerGfx.fillRect(5, 20, 20, 20);
      // Legs.
      playerGfx.fillStyle(0x000000, 1);
      playerGfx.fillRect(8, 40, 4, 10);
      playerGfx.fillRect(18, 40, 4, 10);
      playerGfx.generateTexture("player", 30, 50);
      playerGfx.destroy();

      // Create house texture with door and letterbox.
      let houseGfx = this.add.graphics();
      houseGfx.fillStyle(0x888888, 1);
      houseGfx.fillRect(0, 20, 80, 80);
      houseGfx.fillStyle(0x444444, 1);
      houseGfx.fillTriangle(0, 20, 40, -10, 80, 20);
      houseGfx.fillStyle(0x654321, 1);
      houseGfx.fillRect(30, 60, 20, 40);
      // Letterbox as a horizontal rectangle (centered on door).
      houseGfx.fillStyle(0xffffff, 1);
      houseGfx.fillRect(34, 75, 12, 4);
      houseGfx.generateTexture("house", 80, 100);
      houseGfx.destroy();

      // Create leaflet texture as a portrait rectangle (4x10).
      let leafletGfx = this.add.graphics();
      leafletGfx.fillStyle(0x00ff00, 1);
      leafletGfx.fillRect(0, 0, 4, 10);
      leafletGfx.generateTexture("leaflet", 4, 10);
      leafletGfx.destroy();

      this.load.audio("bleep", "https://labs.phaser.io/assets/audio/SoundEffects/key.wav");
    }
    create() {
      this.houseSpacing = 300;
      this.totalHouses = 10;
      this.houses = [];
      this.totalVotes = { blue: 0, red: 0, yellow: 0, green: 0, turquoise: 0 };
      this.playerLives = 3;
      this.gameOver = false;
      this.playerLost = false;
      this.leaflet = null;
      this.houseSpeed = 2;

      this.player = this.physics.add.sprite(400, 500, "player");
      this.player.setCollideWorldBounds(true);

      this.houseGroup = this.physics.add.group();
      for (let i = 0; i < this.totalHouses; i++) {
        let x = 800 + i * this.houseSpacing;
        let y = Phaser.Math.Between(250, 450);
        let house = this.physics.add.sprite(x, y, "house");
        house.setOrigin(0, 0);
        house.setImmovable(true);
        house.votes = Phaser.Math.Between(1, 4);
        house.hitLetterbox = false;
        house.evaluated = false;
        house.collided = false;
        house.fullRect = new Phaser.Geom.Rectangle(x, y, 80, 100);
        house.doorRect = new Phaser.Geom.Rectangle(x + 30, y + 60, 20, 40);
        house.letterbox = new Phaser.Geom.Rectangle(x + 34, y + 75, 12, 4);
        house.doorNumberText = this.add.text(x + 40, y + 50, house.votes.toString(), { font: "16px Arial", fill: "#fff" }).setOrigin(0.5);
        this.houses.push(house);
        this.houseGroup.add(house);
      }

      // Permanent HUD for votes.
      this.hudBlocks = {};
      const hudStartX = 20, hudStartY = 20, blockSize = 20, blockGap = 10, partyGap = 120;
      const parties = ["blue", "red", "yellow", "green", "turquoise"];
      parties.forEach((party, index) => {
        let block = this.add.rectangle(hudStartX, hudStartY + index * partyGap, blockSize, blockSize, partyColors[party]).setOrigin(0, 0);
        let txt = this.add.text(hudStartX + blockSize + blockGap, hudStartY + index * partyGap, "0", { font: "16px Arial", fill: "#fff" });
        this.hudBlocks[party] = { block, txt };
      });
      this.livesText = this.add.text(20, hudStartY + parties.length * partyGap, "Lives: " + this.playerLives, { font: "16px Arial", fill: "#fff" });

      // On-screen mobile buttons.
      // D-pad (bottom left).
      this.leftBtn = this.add.rectangle(60, 540, 50, 50, 0xffffff, 0.5).setInteractive();
      this.rightBtn = this.add.rectangle(140, 540, 50, 50, 0xffffff, 0.5).setInteractive();
      this.upBtn = this.add.rectangle(100, 490, 50, 50, 0xffffff, 0.5).setInteractive();
      this.downBtn = this.add.rectangle(100, 590, 50, 50, 0xffffff, 0.5).setInteractive();
      // Fire button (bottom right).
      this.fireBtn = this.add.rectangle(740, 540, 60, 60, 0xff0000, 0.5).setInteractive();

      // Movement flags.
      this.moveLeft = false;
      this.moveRight = false;
      this.moveUp = false;
      this.moveDown = false;

      // Set up button events.
      this.leftBtn.on("pointerdown", () => { this.moveLeft = true; });
      this.leftBtn.on("pointerup", () => { this.moveLeft = false; });
      this.leftBtn.on("pointerout", () => { this.moveLeft = false; });
      
      this.rightBtn.on("pointerdown", () => { this.moveRight = true; });
      this.rightBtn.on("pointerup", () => { this.moveRight = false; });
      this.rightBtn.on("pointerout", () => { this.moveRight = false; });
      
      this.upBtn.on("pointerdown", () => { this.moveUp = true; });
      this.upBtn.on("pointerup", () => { this.moveUp = false; });
      this.upBtn.on("pointerout", () => { this.moveUp = false; });
      
      this.downBtn.on("pointerdown", () => { this.moveDown = true; });
      this.downBtn.on("pointerup", () => { this.moveDown = false; });
      this.downBtn.on("pointerout", () => { this.moveDown = false; });
      
      this.fireBtn.on("pointerdown", () => {
        if (!this.leaflet) {
          this.fireLeaflet();
        }
      });

      // Keyboard input (arrows and WASD).
      this.cursors = this.input.keyboard.createCursorKeys();
      this.wasd = this.input.keyboard.addKeys({ 
        up: Phaser.Input.Keyboard.KeyCodes.W, 
        left: Phaser.Input.Keyboard.KeyCodes.A, 
        down: Phaser.Input.Keyboard.KeyCodes.S, 
        right: Phaser.Input.Keyboard.KeyCodes.D 
      });
      this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

      // Player-house collision.
      this.physics.add.overlap(this.player, this.houseGroup, this.handlePlayerHouseCollision, null, this);

      // Game Over text.
      this.gameOverText = this.add.text(400, 300, "Game Over\nClick to Play Again", { font: "32px Arial", fill: "#fff", align: "center" });
      this.gameOverText.setOrigin(0.5);
      this.gameOverText.setVisible(false);
      this.input.on("pointerdown", () => {
        if (this.gameOver) {
          this.scene.restart();
        }
      });
    }
    fireLeaflet() {
      this.leaflet = this.physics.add.sprite(this.player.x, this.player.y - 15, "leaflet");
      this.leaflet.setVelocityY(-300);
    }
    updateHUD() {
      for (const party in this.hudBlocks) {
        this.hudBlocks[party].txt.setText(this.totalVotes[party] ? this.totalVotes[party].toString() : "0");
      }
      this.livesText.setText("Lives: " + this.playerLives);
    }
    handlePlayerHouseCollision(player, house) {
      if (!house.collided) {
        house.collided = true;
        this.playerLives--;
        this.updateHUD();
        if (this.playerLives > 0) {
          this.player.setPosition(400, 500);
        } else {
          this.playerLost = true;
          this.endGame();
        }
      }
    }
    computeVotes(voteCount, boosted) {
      let distribution = { blue: 0, red: 0, yellow: 0, green: 0, turquoise: 0 };
      for (let i = 0; i < voteCount; i++) {
        let rnd = Math.random();
        if (boosted) {
          if (rnd < 0.5) {
            distribution[playerParty]++;
          } else {
            let others = ["blue", "red", "yellow", "green", "turquoise"].filter(p => p !== playerParty);
            let idx = Math.floor(Math.random() * others.length);
            distribution[others[idx]]++;
          }
        } else {
          if (rnd < 0.2) {
            distribution["blue"]++;
          } else if (rnd < 0.4) {
            distribution["red"]++;
          } else if (rnd < 0.6) {
            distribution["yellow"]++;
          } else if (rnd < 0.8) {
            distribution["green"]++;
          } else {
            distribution["turquoise"]++;
          }
        }
      }
      return distribution;
    }
    explodeLeaflet(leaflet) {
      let explosion = this.add.circle(leaflet.x, leaflet.y, 10, 0xff0000);
      this.tweens.add({
        targets: explosion,
        alpha: 0,
        duration: 300,
        onComplete: () => { explosion.destroy(); }
      });
    }
    update(time, delta) {
      if (this.gameOver) return;
      // Keyboard movement.
      if (this.cursors.left.isDown || this.wasd.left.isDown) {
        this.player.setVelocityX(-150);
      } else if (this.cursors.right.isDown || this.wasd.right.isDown) {
        this.player.setVelocityX(150);
      } else {
        this.player.setVelocityX(0);
      }
      if (this.cursors.up.isDown || this.wasd.up.isDown) {
        this.player.setVelocityY(-150);
      } else if (this.cursors.down.isDown || this.wasd.down.isDown) {
        this.player.setVelocityY(150);
      } else {
        this.player.setVelocityY(0);
      }
      // Mobile button movement.
      if (this.moveLeft) { this.player.setVelocityX(-150); }
      if (this.moveRight) { this.player.setVelocityX(150); }
      if (this.moveUp) { this.player.setVelocityY(-150); }
      if (this.moveDown) { this.player.setVelocityY(150); }

      // Launch leaflet on keyboard.
      if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && !this.leaflet) {
        this.fireLeaflet();
      }
      // Process leaflet.
      if (this.leaflet) {
        if (this.leaflet.y < 0) {
          this.leaflet.destroy();
          this.leaflet = null;
        } else {
          let leafletCenter = { x: this.leaflet.x, y: this.leaflet.y };
          for (let i = 0; i < this.houses.length; i++) {
            let house = this.houses[i];
            house.fullRect = new Phaser.Geom.Rectangle(house.x, house.y, 80, 100);
            house.doorRect = new Phaser.Geom.Rectangle(house.x + 30, house.y + 60, 20, 40);
            house.letterbox = new Phaser.Geom.Rectangle(house.x + 34, house.y + 75, 12, 4);
            if (Phaser.Geom.Rectangle.ContainsPoint(house.fullRect, leafletCenter)) {
              if (Phaser.Geom.Rectangle.ContainsPoint(house.letterbox, leafletCenter)) {
                if (!house.hitLetterbox) {
                  house.hitLetterbox = true;
                  let distribution = this.computeVotes(house.votes, true);
                  for (let p in distribution) {
                    this.totalVotes[p] += distribution[p];
                  }
                  this.updateHUD();
                  let maxVotes = Math.max(distribution.blue, distribution.red, distribution.yellow, distribution.green, distribution.turquoise);
                  let winners = [];
                  if (distribution.blue === maxVotes) winners.push("blue");
                  if (distribution.red === maxVotes) winners.push("red");
                  if (distribution.yellow === maxVotes) winners.push("yellow");
                  if (distribution.green === maxVotes) winners.push("green");
                  if (distribution.turquoise === maxVotes) winners.push("turquoise");
                  if (winners.length === 1) {
                    let tint;
                    switch(winners[0]) {
                      case "blue": tint = partyColors.blue; break;
                      case "red": tint = partyColors.red; break;
                      case "yellow": tint = partyColors.yellow; break;
                      case "green": tint = partyColors.green; break;
                      case "turquoise": tint = partyColors.turquoise; break;
                    }
                    house.setTint(tint);
                  } else {
                    house.clearTint();
                  }
                  this.sound.play("bleep");
                }
                this.leaflet.destroy();
                this.leaflet = null;
                break;
              }
              if (!Phaser.Geom.Rectangle.ContainsPoint(house.doorRect, leafletCenter)) {
                this.explodeLeaflet(this.leaflet);
                this.leaflet.destroy();
                this.leaflet = null;
                break;
              }
            }
          }
        }
      }
      this.houses.forEach(function(house) {
        if (!house.evaluated) {
          house.x -= this.houseSpeed;
          house.fullRect = new Phaser.Geom.Rectangle(house.x, house.y, 80, 100);
          house.doorRect.setTo(house.x + 30, house.y + 60, 20, 40);
          house.letterbox.setTo(house.x + 34, house.y + 75, 12, 4);
          if (house.doorNumberText) {
            house.doorNumberText.setPosition(house.x + 40, house.y + 50);
          }
          if (house.x + 80 < 0) {
            if (house.doorNumberText) {
              house.doorNumberText.destroy();
            }
            house.evaluated = true;
            house.destroy();
          }
        }
      }, this);
      if (this.houses.every(function(h) { return h.evaluated; })) {
        this.endGame();
      }
    }
    endGame() {
      this.gameOver = true;
      this.player.setVelocity(0);
      if (this.leaflet) {
        this.leaflet.destroy();
        this.leaflet = null;
      }
      this.gameOverText.setVisible(false);
      this.showResults();
    }
    showResults() {
      let scores = [
        { party: "blue", score: this.totalVotes.blue },
        { party: "red", score: this.totalVotes.red },
        { party: "yellow", score: this.totalVotes.yellow },
        { party: "green", score: this.totalVotes.green },
        { party: "turquoise", score: this.totalVotes.turquoise }
      ];
      scores.sort(function(a, b) { return b.score - a.score; });
      let maxScore = scores[0].score || 1;
      const scoreColors = {
        blue: partyColors.blue,
        red: partyColors.red,
        yellow: partyColors.yellow,
        green: partyColors.green,
        turquoise: partyColors.turquoise
      };
      let chartX = 50;
      let chartY = 550;
      let barWidth = 100;
      let maxBarHeight = 200;
      let gap = 20;
      let graphics = this.add.graphics();
      scores.forEach(function(entry, index) {
        let barHeight = (entry.score / maxScore) * maxBarHeight;
        let x = chartX + index * (barWidth + gap);
        let y = chartY - barHeight;
        graphics.fillStyle(scoreColors[entry.party], 1);
        graphics.fillRect(x, y, barWidth, barHeight);
        // Display a colored block and vote count.
        this.add.rectangle(x + barWidth / 2, chartY + 30, 20, 20, scoreColors[entry.party]).setOrigin(0.5);
        this.add.text(x + barWidth / 2, chartY + 55, entry.score.toString(), { font: "20px Arial", fill: "#fff", align: "center" }).setOrigin(0.5);
      }, this);
      if (!this.playerLost) {
        if (scores[0].score > (scores[1] ? scores[1].score : 0)) {
          if (scores[0].party === playerParty) {
            this.add.text(400, 100, "WINNER", { font: "80px Arial", fill: "#fff" }).setOrigin(0.5);
          }
        } else {
          this.add.text(400, 100, "DRAW LOTS", { font: "80px Arial", fill: "#fff" }).setOrigin(0.5);
        }
      }
    }
  }

  const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    backgroundColor: "#333333",
    physics: { default: "arcade", arcade: { debug: false } },
    scene: [MenuScene, GameScene]
  };

  const game = new Phaser.Game(config);
</script>
</body>
</html>