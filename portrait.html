<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Political Canvasser - Portrait Mobile Version</title>
  <style>
    body { margin: 0; }
    canvas { display: block; margin: 0 auto; background-color: #333333; }
  </style>
  <!-- Import Phaser 3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
<script>
  // Global party color mapping.
  const partyColors = {
    blue: 0x0000ff,
    red: 0xff0000,
    yellow: 0xffff00,
    green: 0x00ff00,
    turquoise: 0x40E0D0
  };

  let playerParty = null;

  // Menu Scene: Party selection and rules.
  class MenuScene extends Phaser.Scene {
    constructor() {
      super({ key: "MenuScene" });
    }
    create() {
      const centerX = this.cameras.main.width / 2;
      const centerY = this.cameras.main.height / 2;
      this.add.text(centerX, centerY - 140, "Choose Your Party", { font: "32px Arial", fill: "#fff" }).setOrigin(0.5);
      
      // Updated rules text.
      const rulesText = "Move with arrows or WASD (or tap the on-screen buttons) and press spacebar (or tap the fire button) to deliver a leaflet.\n" +
                        "Each house displays a door number (voter count) above the door.\n" +
                        "Houses fall from the top â€“ position yourself underneath a house to deliver a leaflet into its letterbox, then move out of the way.\n" +
                        "Don't trespass onto a house or you lose a life.";
      this.add.text(centerX, centerY - 80, rulesText, { font: "18px Arial", fill: "#fff", align: "center" }).setOrigin(0.5);
      
      // Party selection: Display each party as a colored block.
      const parties = ["blue", "red", "yellow", "green", "turquoise"];
      parties.forEach((party, index) => {
        let block = this.add.rectangle(centerX, centerY + 20 + index * 60, 100, 40, partyColors[party]);
        block.setStrokeStyle(2, 0xffffff);
        block.setInteractive();
        block.on("pointerdown", () => {
          playerParty = party;
          this.scene.start("GameScene");
        });
      });
    }
  }

  // Game Scene: Main gameplay and results display.
  class GameScene extends Phaser.Scene {
    constructor() {
      super({ key: "GameScene" });
    }
    preload() {
      // Create a person-like player texture.
      let playerGfx = this.add.graphics();
      // Head.
      playerGfx.fillStyle(0xffcc99, 1);
      playerGfx.fillCircle(15, 10, 10);
      // Body: use player's party color if set; otherwise white.
      let bodyColor = playerParty ? partyColors[playerParty] : 0xffffff;
      playerGfx.fillStyle(bodyColor, 1);
      playerGfx.fillRect(5, 20, 20, 20);
      // Legs.
      playerGfx.fillStyle(0x000000, 1);
      playerGfx.fillRect(8, 40, 4, 10);
      playerGfx.fillRect(18, 40, 4, 10);
      playerGfx.generateTexture("player", 30, 50);
      playerGfx.destroy();

      // Create house texture with door and letterbox.
      let houseGfx = this.add.graphics();
      houseGfx.fillStyle(0x888888, 1);
      houseGfx.fillRect(0, 20, 80, 80);
      houseGfx.fillStyle(0x444444, 1);
      houseGfx.fillTriangle(0, 20, 40, -10, 80, 20);
      houseGfx.fillStyle(0x654321, 1);
      houseGfx.fillRect(30, 60, 20, 40);
      // Draw letterbox as a horizontal rectangle.
      // Door center is at x=40 so letterbox starts at x=40-6=34, width=12, height=4.
      houseGfx.fillStyle(0xffffff, 1);
      houseGfx.fillRect(34, 75, 12, 4);
      houseGfx.generateTexture("house", 80, 100);
      houseGfx.destroy();

      // Create leaflet texture as a portrait rectangle (4x10).
      let leafletGfx = this.add.graphics();
      leafletGfx.fillStyle(0x00ff00, 1);
      leafletGfx.fillRect(0, 0, 4, 10);
      leafletGfx.generateTexture("leaflet", 4, 10);
      leafletGfx.destroy();

      // Preload the "bleep" sound.
      this.load.audio("bleep", "https://labs.phaser.io/assets/audio/SoundEffects/key.wav");
    }
    create() {
      // Configure for portrait orientation (600x900).
      this.houseSpacing = 300;
      this.totalHouses = 10;
      this.houses = [];
      this.totalVotes = { blue: 0, red: 0, yellow: 0, green: 0, turquoise: 0 };
      this.playerLives = 3;
      this.gameOver = false;
      this.playerLost = false;
      this.leaflet = null;
      this.houseSpeed = 2;

      // Player starts near the bottom center.
      this.player = this.physics.add.sprite(300, 800, "player");
      this.player.setCollideWorldBounds(true);

      // Create houses that fall downwards.
      this.houseGroup = this.physics.add.group();
      for (let i = 0; i < this.totalHouses; i++) {
        // Random horizontal position between 0 and 520 (600 - 80).
        let x = Phaser.Math.Between(0, 520);
        // Houses spawn above the screen.
        let y = -Phaser.Math.Between(50, 150) - i * this.houseSpacing;
        let house = this.physics.add.sprite(x, y, "house");
        house.setOrigin(0, 0);
        house.setImmovable(true);
        house.votes = Phaser.Math.Between(1, 4);
        house.hitLetterbox = false;
        house.evaluated = false;
        house.collided = false;
        house.fullRect = new Phaser.Geom.Rectangle(x, y, 80, 100);
        // Door region remains at (30,60) relative to house texture.
        house.doorRect = new Phaser.Geom.Rectangle(x + 30, y + 60, 20, 40);
        // Letterbox region (for collision) is defined to match drawn letterbox.
        // To improve detection, we use an intersection test.
        house.letterbox = new Phaser.Geom.Rectangle(x + 34, y + 75, 12, 4);
        // Create door number text (voter count) above the door.
        house.doorNumberText = this.add.text(x + 40, y + 50, house.votes.toString(), { font: "16px Arial", fill: "#fff" }).setOrigin(0.5);
        this.houses.push(house);
        this.houseGroup.add(house);
      }

      // Create a permanent HUD for votes.
      this.hudBlocks = {};
      const hudStartX = 20, hudStartY = 20, blockSize = 20, blockGap = 10, partyGap = 120;
      const parties = ["blue", "red", "yellow", "green", "turquoise"];
      parties.forEach((party, index) => {
        let block = this.add.rectangle(hudStartX, hudStartY + index * partyGap, blockSize, blockSize, partyColors[party]).setOrigin(0, 0);
        let txt = this.add.text(hudStartX + blockSize + blockGap, hudStartY + index * partyGap, "0", { font: "16px Arial", fill: "#fff" });
        this.hudBlocks[party] = { block, txt };
      });
      this.livesText = this.add.text(20, hudStartY + parties.length * partyGap, "Lives: " + this.playerLives, { font: "16px Arial", fill: "#fff" });

      // On-screen mobile buttons.
      // D-pad on bottom left.
      this.leftBtn = this.add.rectangle(40, 840, 50, 50, 0xffffff, 0.5).setInteractive();
      this.rightBtn = this.add.rectangle(120, 840, 50, 50, 0xffffff, 0.5).setInteractive();
      this.upBtn = this.add.rectangle(80, 800, 50, 50, 0xffffff, 0.5).setInteractive();
      this.downBtn = this.add.rectangle(80, 880, 50, 50, 0xffffff, 0.5).setInteractive();
      // Fire button on bottom right.
      this.fireBtn = this.add.rectangle(520, 840, 60, 60, 0xff0000, 0.5).setInteractive();

      // Movement flags.
      this.moveLeft = false;
      this.moveRight = false;
      this.moveUp = false;
      this.moveDown = false;

      // Set up on-screen button events.
      this.leftBtn.on("pointerdown", () => { this.moveLeft = true; });
      this.leftBtn.on("pointerup", () => { this.moveLeft = false; });
      this.leftBtn.on("pointerout", () => { this.moveLeft = false; });
      
      this.rightBtn.on("pointerdown", () => { this.moveRight = true; });
      this.rightBtn.on("pointerup", () => { this.moveRight = false; });
      this.rightBtn.on("pointerout", () => { this.moveRight = false; });
      
      this.upBtn.on("pointerdown", () => { this.moveUp = true; });
      this.upBtn.on("pointerup", () => { this.moveUp = false; });
      this.upBtn.on("pointerout", () => { this.moveUp = false; });
      
      this.downBtn.on("pointerdown", () => { this.moveDown = true; });
      this.downBtn.on("pointerup", () => { this.moveDown = false; });
      this.downBtn.on("pointerout", () => { this.moveDown = false; });
      
      this.fireBtn.on("pointerdown", () => {
        if (!this.leaflet) { this.fireLeaflet(); }
      });

      // Keyboard input (arrows and WASD).
      this.cursors = this.input.keyboard.createCursorKeys();
      this.wasd = this.input.keyboard.addKeys({ 
        up: Phaser.Input.Keyboard.KeyCodes.W, 
        left: Phaser.Input.Keyboard.KeyCodes.A, 
        down: Phaser.Input.Keyboard.KeyCodes.S, 
        right: Phaser.Input.Keyboard.KeyCodes.D 
      });
      this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

      // Player-house collision.
      this.physics.add.overlap(this.player, this.houseGroup, this.handlePlayerHouseCollision, null, this);

      // Game Over text.
      this.gameOverText = this.add.text(300, 450, "Game Over\nTap to Play Again", { font: "32px Arial", fill: "#fff", align: "center" });
      this.gameOverText.setOrigin(0.5);
      this.gameOverText.setVisible(false);
      this.input.on("pointerdown", () => {
        if (this.gameOver) { this.scene.restart(); }
      });
    }
    fireLeaflet() {
      this.leaflet = this.physics.add.sprite(this.player.x, this.player.y - 15, "leaflet");
      this.leaflet.setVelocityY(-300);
    }
    updateHUD() {
      for (const party in this.hudBlocks) {
        this.hudBlocks[party].txt.setText(this.totalVotes[party] ? this.totalVotes[party].toString() : "0");
      }
      this.livesText.setText("Lives: " + this.playerLives);
    }
    handlePlayerHouseCollision(player, house) {
      if (!house.collided) {
        house.collided = true;
        this.playerLives--;
        this.updateHUD();
        if (this.playerLives > 0) {
          this.player.setPosition(300, 800);
        } else {
          this.playerLost = true;
          this.endGame();
        }
      }
    }
    computeVotes(voteCount, boosted) {
      let distribution = { blue: 0, red: 0, yellow: 0, green: 0, turquoise: 0 };
      for (let i = 0; i < voteCount; i++) {
        let rnd = Math.random();
        if (boosted) {
          if (rnd < 0.5) {
            distribution[playerParty]++;
          } else {
            let others = ["blue", "red", "yellow", "green", "turquoise"].filter(p => p !== playerParty);
            let idx = Math.floor(Math.random() * others.length);
            distribution[others[idx]]++;
          }
        } else {
          if (rnd < 0.2) {
            distribution["blue"]++;
          } else if (rnd < 0.4) {
            distribution["red"]++;
          } else if (rnd < 0.6) {
            distribution["yellow"]++;
          } else if (rnd < 0.8) {
            distribution["green"]++;
          } else {
            distribution["turquoise"]++;
          }
        }
      }
      return distribution;
    }
    explodeLeaflet(leaflet) {
      let explosion = this.add.circle(leaflet.x, leaflet.y, 10, 0xff0000);
      this.tweens.add({
        targets: explosion,
        alpha: 0,
        duration: 300,
        onComplete: () => { explosion.destroy(); }
      });
    }
    update(time, delta) {
      if (this.gameOver) return;
      // Combine keyboard and on-screen input for horizontal movement.
      let velocityX = 0, velocityY = 0;
      if (this.cursors.left.isDown || this.wasd.left.isDown || this.moveLeft) { velocityX = -150; }
      else if (this.cursors.right.isDown || this.wasd.right.isDown || this.moveRight) { velocityX = 150; }
      if (this.cursors.up.isDown || this.wasd.up.isDown || this.moveUp) { velocityY = -150; }
      else if (this.cursors.down.isDown || this.wasd.down.isDown || this.moveDown) { velocityY = 150; }
      this.player.setVelocity(velocityX, velocityY);

      // Launch leaflet on keyboard.
      if (Phaser.Input.Keyboard.JustDown(this.spaceKey) && !this.leaflet) { this.fireLeaflet(); }

      // Process leaflet.
      if (this.leaflet) {
        if (this